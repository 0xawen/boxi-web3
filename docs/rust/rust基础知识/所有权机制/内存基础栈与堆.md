# 内存基础

rust 的重点在于所有权机制， 理解所有权机制在于夯实内存知识，所以重点学习一 栈和堆的内存空间。

**栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。**

## 栈空间

栈的特点： 

- 数据是先进后出
- 栈空间存放的数据一般都是已知大小的数据
- 处理数据性能是非常速度的



## 堆空间

堆特点：

- 堆上一般存放较大的数据或者是位置大小的数据
- 在堆上申请空间返回该空间的地址，一般称为指针。

- 处理数据比较慢

当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。



因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。



## 变量与数据之间的交互

### 拷贝(浅拷贝) --- 栈中的数据复制copy

在rust 中，浅拷贝发生在栈空间上。也就是说数据的大小是已知的，在栈中拷贝性能是非常高的。

rust中有`copy` 特征，如果一个类型拥有 `Copy` 特征，一个旧的变量在被赋值给其他变量后仍然可用。所有权不会变化。

基本类型都实现了 copy 特征。

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
// 这里 x 将所有权转移给了y, 然后使用在使用 x,似乎是违反了所有权的规则。
// 但是 基本变量是实现copy 特征，直接拷贝了一份给y（值；5）
```

- 所有整数类型，比如 `u32`。
- 布尔类型，`bool`，它的值是 `true` 和 `false`。
- 所有浮点数类型，比如 `f64`。
- 字符类型，`char`。
- 元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 就不是。
- 不可变引用 `&T` ，**但是注意: 可变引用 `&mut T` 是不可以 Copy的**



### 深拷贝(克隆) --- 堆中的数据复制clone

首先，**Rust 永远也不会自动创建数据的 “深拷贝”**。因此，任何**自动**的复制都不是深拷贝，可以被认为对运行时性能影响较小。

如果确实需要， 可以使用`clone`特征。

```rust
let s1 = String::from("hello");
let s2 = s1.clone()

println!("s1 = {}, s2 = {}", s1, s2);

// s2 完整的复制了 s1 的数据
```



### 转移所有权 --- move

```rust
// String 由存储在栈中的堆指针、字符串长度、字符串容量共同组成
// s1 将 （堆指针、字符串长度、字符串容量） copy 给了 s2, 而不是将内容赋值给s2。
let s1 = String::from("hello");
let s2 = s1;
```

**当 `s1` 赋予 `s2` 后，Rust 认为 `s1` 不再有效，因此也无需在 `s1` 离开作用域后 `drop` 任何东西，这就是把所有权从 `s1` 转移给了 `s2`，`s1` 在被赋予 `s2` 后就马上失效了**。