# 闭包

闭包是**一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值**



## 闭包写法

```rust
let sum = |x: i32, y: i32| -> u32 {
    x + y
}
let v = sum(1,2);
```



## 闭包捕获作用域的值

当闭包从环境中捕获一个值时，会分配内存去存储这些值。

对于有些场景来说，这种额外的内存分配会成为一种负担。

与之相比，函数就不会去捕获这些环境值，因此定义和使用函数不会拥有这种内存负担。

### 三种Fn特征

闭包捕获变量有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用

- `FnOnce`,  闭包拿走被捕获变量的所有权。
- `FnMut`，它以可变借用的方式捕获了环境中的值，因此可以修改该值。
- `Fn` 特征，它以不可变借用的方式捕获环境中的值。

### 三种Fn的关系

- 所有的闭包都自动实现了 `FnOnce` 特征，因此任何一个闭包都至少可以被调用一次
- 没有移出所捕获变量的所有权的闭包自动实现了 `FnMut` 特征
- 不需要对捕获变量进行改变的闭包自动实现了 `Fn` 特征

### move关键字

如果想强制闭包取得捕获变量的所有权，可以在参数列表前添加 `move` 关键字。

通常用于闭包的生命周期大于捕获变量的生命周期时，例如将闭包返回或移入其他线程。



## 闭包的使用


### 作为函数的返回值

使用特征对象解决问题

```rust
fn factory(x: i32) -> Box<dyn Fn(i32) -> i32> {
    let num = 5;
    if x > 1 {
        Box::new(move |x| x + num)
    }else {
        Box::new(move |x| x + num)
    }
}
```


### 闭包在结构体中使用
实现一个简易缓存，功能是获取一个值，然后将其缓存起来:

- 一个闭包用于获取值
- 一个变量，用于存储该值

```rust
struct Cacher<T> 
where 
	T: Fn(u32) -> u32,
{
    query: T,
    value: Optin<u32>,
}
//  Fn 特征不仅仅适用于闭包，还适用于函数，
// 因此上面的 query 字段除了使用闭包作为值外，还能使用一个具名的函数来作为它的值

impl <T> Cacher <T>
where
	T: Fn(u32) -> u32
{
     fn new(query: T) -> Cacher<T> {
        Cacher {
            query,
            value: None,
        }
    }

    // 先查询缓存值 `self.value`，若不存在，则调用 `query` 加载
    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.query)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}

```