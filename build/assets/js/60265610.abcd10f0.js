"use strict";(self.webpackChunkweb_3_blog=self.webpackChunkweb_3_blog||[]).push([[7663],{3905:(n,t,e)=>{e.d(t,{Zo:()=>l,kt:()=>d});var r=e(7294);function a(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function o(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,r)}return e}function c(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?o(Object(e),!0).forEach((function(t){a(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function i(n,t){if(null==n)return{};var e,r,a=function(n,t){if(null==n)return{};var e,r,a={},o=Object.keys(n);for(r=0;r<o.length;r++)e=o[r],t.indexOf(e)>=0||(a[e]=n[e]);return a}(n,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)e=o[r],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(a[e]=n[e])}return a}var s=r.createContext({}),u=function(n){var t=r.useContext(s),e=t;return n&&(e="function"==typeof n?n(t):c(c({},t),n)),e},l=function(n){var t=u(n.components);return r.createElement(s.Provider,{value:t},n.children)},_={inlineCode:"code",wrapper:function(n){var t=n.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(n,t){var e=n.components,a=n.mdxType,o=n.originalType,s=n.parentName,l=i(n,["components","mdxType","originalType","parentName"]),p=u(e),d=a,m=p["".concat(s,".").concat(d)]||p[d]||_[d]||o;return e?r.createElement(m,c(c({ref:t},l),{},{components:e})):r.createElement(m,c({ref:t},l))}));function d(n,t){var e=arguments,a=t&&t.mdxType;if("string"==typeof n||a){var o=e.length,c=new Array(o);c[0]=p;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=n,i.mdxType="string"==typeof n?n:a,c[1]=i;for(var u=2;u<o;u++)c[u]=e[u];return r.createElement.apply(null,c)}return r.createElement.apply(null,e)}p.displayName="MDXCreateElement"},6184:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>s,contentTitle:()=>c,default:()=>_,frontMatter:()=>o,metadata:()=>i,toc:()=>u});var r=e(7462),a=(e(7294),e(3905));const o={},c="\u66f4\u6539account size",i={unversionedId:"rust_contract/solana/solana_\u5408\u7ea6\u5f00\u53d1\u5e93/change_account_size",id:"rust_contract/solana/solana_\u5408\u7ea6\u5f00\u53d1\u5e93/change_account_size",title:"\u66f4\u6539account size",description:"\u4f7f\u7528 realloc \u66f4\u6539\u7a0b\u5e8f\u62e5\u6709\u5e10\u6237\u7684\u5927\u5c0f\u3002realloc \u53ef\u4ee5\u5c06\u5e10\u6237\u5927\u5c0f\u8c03\u6574\u5230 10KB\u3002",source:"@site/docs\\rust_contract\\solana\\02_solana_\u5408\u7ea6\u5f00\u53d1\u5e93\\change_account_size.md",sourceDirName:"rust_contract/solana/02_solana_\u5408\u7ea6\u5f00\u53d1\u5e93",slug:"/rust_contract/solana/solana_\u5408\u7ea6\u5f00\u53d1\u5e93/change_account_size",permalink:"/docs/rust_contract/solana/solana_\u5408\u7ea6\u5f00\u53d1\u5e93/change_account_size",draft:!1,tags:[],version:"current",frontMatter:{}},s={},u=[],l={toc:u};function _(n){let{components:t,...e}=n;return(0,a.kt)("wrapper",(0,r.Z)({},l,e,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"\u66f4\u6539account-size"},"\u66f4\u6539account size"),(0,a.kt)("p",null,"\u4f7f\u7528 realloc \u66f4\u6539\u7a0b\u5e8f\u62e5\u6709\u5e10\u6237\u7684\u5927\u5c0f\u3002realloc \u53ef\u4ee5\u5c06\u5e10\u6237\u5927\u5c0f\u8c03\u6574\u5230 10KB\u3002"),(0,a.kt)("p",null,"\u5f53\u60a8\u4f7f\u7528 realloc \u6765\u589e\u52a0\u5e10\u6237\u7684\u5927\u5c0f\u65f6\uff0c\u60a8\u5fc5\u987b\u8f6c\u79fb lamports \u4ee5\u4fdd\u6301\u8be5\u5e10\u6237\u514d\u79df"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use {\n  crate::{\n      instruction::WhitelistInstruction,\n      state::WhiteListData,\n  },\n  borsh::{BorshDeserialize, BorshSerialize},\n  solana_program::{\n      account_info::{next_account_info, AccountInfo},\n      entrypoint::ProgramResult,\n      msg,\n      program::invoke_signed,\n      program::invoke,\n      program_error::ProgramError,\n      pubkey::Pubkey,\n      sysvar::Sysvar,\n      sysvar::rent::Rent,\n      system_instruction,\n  },\n  std::convert::TryInto,\n};\n\npub fn process_instruction(\n    _program_id: &Pubkey,\n    acconts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n   const INITIAL_ACCOUNT_LEN: usize = 1 + 4 + 0;\n   msg!("input: {:?}", input);\n    \n  let instruction = WhitelistInstruction::try_from_slice(input)?;\n    \n  let accounts_iter = &mut accounts.iter();\n    \n  let funding_account = next_account_info(accounts_iter)?;\n  let pda_account = next_account_info(accounts_iter)?;\n  let system_program = next_account_info(accounts_iter)?;\n    \n    match instruction {\n        WhitelistInstruction::Initialize => {\n            msg!("initialize");\n            \n            let (pda, pda_bump) => Pubkey:find_program_address(\n                &[b"customaddress",&funding_account.key.to_bytes()],_program_id,\n            );\n            \n          let signers_seeds: &[&[u8]; 3] = &[\n            b"customaddress",\n            &funding_account.key.to_bytes(),\n            &[pda_bump],\n            ];\n            \n            if pda.ne(&pda_account.key){\n                return Err(ProgramError::InvalidAccountData);\n            }\n            \n            let lamports_required = Rent::get()?.minimum_balance(INITIAL_ACCOUNT_LEN);\n            let create_pda_account_ix = system_instruction::create_account(\n                &funding_account.key,\n                &pda_account.key,\n                lamports_required,\n                INITIAL_ACCOUNT_LEN.try_into().unwrap(),\n                &_program_id,\n            );\n            \n            invoke_signed(\n                &create_pda_account_ix,\n                &[\n                    funding_account.clone(),\n                    pda_account.clone(),\n                    system_program.clone(),\n                ],\n                &[signers_seeds],\n            )?;\n            \n             let mut pda_account_state = WhiteListData::try_from_slice(&pda_account.data.borrow())?;\n\n            pda_account_state.is_initialized = true;\n            pda_account_state.white_list = Vec::new();\n            pda_account_state.serialize(&mut &mut pda_account.data.borrow_mut()[..])?;\n            Ok(())\n        }\n        WhitelistInstruction::AddKey{key} => {\n            msg!("AddKey");\n\n            let mut pda_account_state = WhiteListData::try_from_slice(&pda_account.data.borrow())?;\n      \n            if !pda_account_state.is_initialized {\n                return Err(ProgramError::InvalidAccountData);\n            }\n\n        let new_size = pda_account.data.borrow().len() + 32;\n\n      let rent = Rent::get()?;\n      let new_minimum_balance = rent.minimum_balance(new_size);\n      \n      let lamports_diff = new_minimum_balance.saturating_sub(pda_account.lamports());\n      invoke(\n          &system_instruction::transfer(funding_account.key, pda_account.key, lamports_diff),\n          &[\n              funding_account.clone(),\n              pda_account.clone(),\n              system_program.clone(),\n          ],\n      )?;\n    \n      // raalloc      \n      pda_account.realloc(new_size, false)?;\n\n      pda_account_state.white_list.push(key);\n      pda_account_state.serialize(&mut &mut pda_account.data.borrow_mut()[..])?;\n\n      Ok(())\n        }\n    }\n}\n')))}_.isMDXComponent=!0}}]);