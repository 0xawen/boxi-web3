"use strict";(self.webpackChunkweb_3_blog=self.webpackChunkweb_3_blog||[]).push([[4233],{3905:(n,t,e)=>{e.d(t,{Zo:()=>_,kt:()=>m});var r=e(7294);function o(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function a(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,r)}return e}function c(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?a(Object(e),!0).forEach((function(t){o(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):a(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function s(n,t){if(null==n)return{};var e,r,o=function(n,t){if(null==n)return{};var e,r,o={},a=Object.keys(n);for(r=0;r<a.length;r++)e=a[r],t.indexOf(e)>=0||(o[e]=n[e]);return o}(n,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(r=0;r<a.length;r++)e=a[r],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(o[e]=n[e])}return o}var u=r.createContext({}),i=function(n){var t=r.useContext(u),e=t;return n&&(e="function"==typeof n?n(t):c(c({},t),n)),e},_=function(n){var t=i(n.components);return r.createElement(u.Provider,{value:t},n.children)},l={inlineCode:"code",wrapper:function(n){var t=n.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(n,t){var e=n.components,o=n.mdxType,a=n.originalType,u=n.parentName,_=s(n,["components","mdxType","originalType","parentName"]),p=i(e),m=o,f=p["".concat(u,".").concat(m)]||p[m]||l[m]||a;return e?r.createElement(f,c(c({ref:t},_),{},{components:e})):r.createElement(f,c({ref:t},_))}));function m(n,t){var e=arguments,o=t&&t.mdxType;if("string"==typeof n||o){var a=e.length,c=new Array(a);c[0]=p;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=n,s.mdxType="string"==typeof n?n:o,c[1]=s;for(var i=2;i<a;i++)c[i]=e[i];return r.createElement.apply(null,c)}return r.createElement.apply(null,e)}p.displayName="MDXCreateElement"},5443:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>l,frontMatter:()=>a,metadata:()=>s,toc:()=>i});var r=e(7462),o=(e(7294),e(3905));const a={},c="\u8de8\u5408\u7ea6\u8c03\u7528",s={unversionedId:"rust_contract/solana/solana_\u5408\u7ea6\u5f00\u53d1\u5e93/cross_programg_invocation",id:"rust_contract/solana/solana_\u5408\u7ea6\u5f00\u53d1\u5e93/cross_programg_invocation",title:"\u8de8\u5408\u7ea6\u8c03\u7528",description:"\u8de8\u7a0b\u5e8f\u8c03\u7528\uff0c\u5c31\u662f\u5728\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u8c03\u7528\u53e6\u4e00\u4e2a\u7a0b\u5e8f\u7684\u6307\u4ee4\u3002\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5b83\u662f SPL \u4ee3\u5e01\u8ba1\u5212\u7684\u8f6c\u8d26\u6307\u4ee4\u3002",source:"@site/docs\\rust_contract\\solana\\02_solana_\u5408\u7ea6\u5f00\u53d1\u5e93\\cross_programg_invocation.md",sourceDirName:"rust_contract/solana/02_solana_\u5408\u7ea6\u5f00\u53d1\u5e93",slug:"/rust_contract/solana/solana_\u5408\u7ea6\u5f00\u53d1\u5e93/cross_programg_invocation",permalink:"/docs/rust_contract/solana/solana_\u5408\u7ea6\u5f00\u53d1\u5e93/cross_programg_invocation",draft:!1,tags:[],version:"current",frontMatter:{}},u={},i=[],_={toc:i};function l(n){let{components:t,...e}=n;return(0,o.kt)("wrapper",(0,r.Z)({},_,e,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"\u8de8\u5408\u7ea6\u8c03\u7528"},"\u8de8\u5408\u7ea6\u8c03\u7528"),(0,o.kt)("p",null,"\u8de8\u7a0b\u5e8f\u8c03\u7528\uff0c\u5c31\u662f\u5728\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u8c03\u7528\u53e6\u4e00\u4e2a\u7a0b\u5e8f\u7684\u6307\u4ee4\u3002\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5b83\u662f SPL \u4ee3\u5e01\u8ba1\u5212\u7684\u8f6c\u8d26\u6307\u4ee4\u3002"),(0,o.kt)("p",null,"\u6211\u4eec\u9700\u8981\u8fdb\u884c\u8f6c\u8d26\u6240\u9700\u7684\u8d26\u6237\u662f\uff1a"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"\u6e90\u4ee3\u5e01\u8d26\u6237\uff08\u6211\u4eec\u6301\u6709\u4ee3\u5e01\u7684\u8d26\u6237\uff09")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"\u76ee\u6807\u4ee3\u5e01\u8d26\u6237\uff08\u6211\u4eec\u8981\u5c06\u4ee3\u5e01\u8f6c\u79fb\u5230\u7684\u8d26\u6237\uff09")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"\u6e90\u4ee3\u5e01\u8d26\u6237\u6301\u6709\u4eba\uff08\u6211\u4eec\u5c06\u8981\u7b7e\u540d\u7684\u94b1\u5305\u5730\u5740\uff09"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use solana_program::{\n  account_info::{next_account_info, AccountInfo};\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    program::invoke,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n};\n\nuse spl_token:instruction::transfer;\n\nentrypoint!(process_instruction);\n\n// Accounts required\n/// 1. [writable] Source Token Account\n/// 2. [writable] Destination Token Account\n/// 3. [signer] Source Token Account holder\'s PubKey\n/// 4. [] Token Program\npub fn process_instruction(\n    _program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let account_iter = &mut accounts.iter();\n    \n    // Accounts required for token transfer\n    // 1. token account we hold\n    let source_token_account = next_account_info(accounts_iter)?;\n    // 2. token account to send to\n    let destination_token_account = next_account_info(account_iter)?;\n    // 3. our wallet address\n    let source_token_account_holder = next_account_info(account_iter)?;\n    // 4. token program\n    let token_program = next_account_info(account_iter)?;\n    \n    // Parsing the token transfer amount from instruction data\n    let token_transfer_amount = instruction_data\n        .get(..8)\n        .and_then(|slice| slice.try_into().ok())\n        .map(u64::from_le_bytes)\n        .ok_or(ProgramError::InvalidAccountData)?;\n    \n       msg!(\n        "Transferring {} tokens from {} to {}",\n        token_transfer_amount,\n        source_token_account.key.to_string(),\n        destination_token_account.key.to_string()\n    );\n    \n    \n    // Creating a new TransactionInstruction\n    /*\n        Internal representation of the instruction\'s return value (Result<Instruction, ProgramError>)\n\n        Ok(Instruction {\n            program_id: *token_program_id, // PASSED FROM USER\n            accounts,\n            data,\n        })\n    */\n    \n    let transfer_tokens_instruction = transfer(\n        &token_program.key,\n        &source_token_account.key,\n        &destination_token_account.key,\n        &source_token_account_holder.key,\n        &[&source_token_account_holder.key],\n        token_transfer_amount,\n    )?;\n    \n    let required_accounts_for_transfer = [\n        source_token_account.clone(),\n        destination_token_account.clone(),\n        source_token_account_holder.clone(),\n    ];\n    \n    invoke(\n        &transfer_token_instruction,\n        &required_accounts_for_transfer,\n    )?;\n    \n    msg!("Transfer successful");\n\n    Ok(())\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    program::invoke,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction::create_account,\n    sysvar::Sysvar,\n};\n\nentrypoint!(process_instruction);\n\n// Accounts required\n/// 1. [signer, writable] Payer Account\n/// 2. [signer, writable] General State Account\n/// 3. [] System Program\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n\n    // Accounts required for token transfer\n\n    // 1. Payer account for the state account creation\n    let payer_account = next_account_info(accounts_iter)?;\n    // 2. Token account we hold\n    let general_state_account = next_account_info(accounts_iter)?;\n    // 3. System Program\n    let system_program = next_account_info(accounts_iter)?;\n\n    msg!(\n        "Creating account for {}",\n        general_state_account.key.to_string()\n    );\n\n    // Parsing the token transfer amount from instruction data\n    // a. Getting the 0th to 8th index of the u8 byte array\n    // b. Converting the obtained non zero u8 to a proper u8 (as little endian integers)\n    // c. Converting the little endian integers to a u64 number\n    let account_span = instruction_data\n        .get(..8)\n        .and_then(|slice| slice.try_into().ok())\n        .map(u64::from_le_bytes)\n        .ok_or(ProgramError::InvalidAccountData)?;\n\n    let lamports_required = (Rent::get()?).minimum_balance(account_span as usize);\n\n    // Creating a new TransactionInstruction\n    /*\n        Internal representation of the instruction\'s return value (Instruction)\n\n        Instruction::new_with_bincode(\n            system_program::id(), // NOT PASSED FROM USER\n            &SystemInstruction::CreateAccount {\n                lamports,\n                space,\n                owner: *owner,\n            },\n            account_metas,\n        )\n    */\n\n    let create_account_instruction = create_account(\n        &payer_account.key,\n        &general_state_account.key,\n        lamports_required,\n        account_span,\n        program_id,\n    );\n\n    let required_accounts_for_create = [\n        payer_account.clone(),\n        general_state_account.clone(),\n        system_program.clone(),\n    ];\n\n    // Passing the TransactionInstruction to send (with the issused program_id)\n    invoke(&create_account_instruction, &required_accounts_for_create)?;\n\n    msg!("Transfer successful");\n\n    Ok(())\n}\n')))}l.isMDXComponent=!0}}]);