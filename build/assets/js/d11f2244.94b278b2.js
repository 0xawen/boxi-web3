"use strict";(self.webpackChunkweb_3_blog=self.webpackChunkweb_3_blog||[]).push([[6810],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>l});var r=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,s=function(e,n){if(null==e)return{};var t,r,s={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var c=r.createContext({}),g=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=g(e.components);return r.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,s=e.mdxType,i=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),f=g(t),l=s,y=f["".concat(c,".").concat(l)]||f[l]||d[l]||i;return t?r.createElement(y,a(a({ref:n},u),{},{components:t})):r.createElement(y,a({ref:n},u))}));function l(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var i=t.length,a=new Array(i);a[0]=f;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:s,a[1]=o;for(var g=2;g<i;g++)a[g]=t[g];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},6608:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>g});var r=t(7462),s=(t(7294),t(3905));const i={},a="\u9a8c\u8bc1\u7b7e\u540d",o={unversionedId:"solidity/solidity_basic/verifying_signature",id:"solidity/solidity_basic/verifying_signature",title:"\u9a8c\u8bc1\u7b7e\u540d",description:"\u6d88\u606f\u53ef\u4ee5\u5728\u94fe\u4e0b\u7b7e\u540d\uff0c\u7136\u540e\u4f7f\u7528\u667a\u80fd\u5408\u7ea6\u5728\u94fe\u4e0a\u8fdb\u884c\u9a8c\u8bc1\u3002",source:"@site/docs/solidity/solidity_basic/41_verifying_signature.md",sourceDirName:"solidity/solidity_basic",slug:"/solidity/solidity_basic/verifying_signature",permalink:"/docs/solidity/solidity_basic/verifying_signature",draft:!1,tags:[],version:"current",sidebarPosition:41,frontMatter:{},sidebar:"solidity",previous:{title:"keccak256",permalink:"/docs/solidity/solidity_basic/hashing_with_keccak256"},next:{title:"\u8282\u7701gas\u7684\u6280\u5de7",permalink:"/docs/solidity/solidity_basic/gas_saving_techniques"}},c={},g=[],u={toc:g};function d(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"\u9a8c\u8bc1\u7b7e\u540d"},"\u9a8c\u8bc1\u7b7e\u540d"),(0,s.kt)("p",null,"\u6d88\u606f\u53ef\u4ee5\u5728\u94fe\u4e0b\u7b7e\u540d\uff0c\u7136\u540e\u4f7f\u7528\u667a\u80fd\u5408\u7ea6\u5728\u94fe\u4e0a\u8fdb\u884c\u9a8c\u8bc1\u3002"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/* Signature Verification\n\nHow to Sign and Verify\n# Signing\n1. Create message to sign\n2. Hash the message\n3. Sign the hash (off chain, keep your private key secret)\n\n# Verify\n1. Recreate hash from the original message\n2. Recover signer from signature and hash\n3. Compare recovered signer to claimed signer\n*/\n\ncontract VerifySignature {\n    /* 1. Unlock MetaMask account\n    ethereum.enable()\n    */\n\n    /* 2. Get message hash to sign\n    getMessageHash(\n        0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C,\n        123,\n        "coffee and donuts",\n        1\n    )\n\n    hash = "0xcf36ac4f97dc10d91fc2cbb20d718e94a8cbfe0f82eaedc6a4aa38946fb797cd"\n    */\n    function getMessageHash(\n        address _to,\n        uint _amount,\n        string memory _message,\n        uint _nonce\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_to, _amount, _message, _nonce));\n    }\n\n    /* 3. Sign message hash\n    # using browser\n    account = "copy paste account of signer here"\n    ethereum.request({ method: "personal_sign", params: [account, hash]}).then(console.log)\n\n    # using web3\n    web3.personal.sign(hash, web3.eth.defaultAccount, console.log)\n\n    Signature will be different for different accounts\n    0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function getEthSignedMessageHash(bytes32 _messageHash)\n        public\n        pure\n        returns (bytes32)\n    {\n        /*\n        Signature is produced by signing a keccak256 hash with the following format:\n        "\\x19Ethereum Signed Message\\n" + len(msg) + msg\n        */\n        return\n            keccak256(\n                abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _messageHash)\n            );\n    }\n\n    /* 4. Verify signature\n    signer = 0xB273216C05A8c0D4F0a4Dd0d7Bae1D2EfFE636dd\n    to = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C\n    amount = 123\n    message = "coffee and donuts"\n    nonce = 1\n    signature =\n        0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function verify(\n        address _signer,\n        address _to,\n        uint _amount,\n        string memory _message,\n        uint _nonce,\n        bytes memory signature\n    ) public pure returns (bool) {\n        bytes32 messageHash = getMessageHash(_to, _amount, _message, _nonce);\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n        return recoverSigner(ethSignedMessageHash, signature) == _signer;\n    }\n\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\n        public\n        pure\n        returns (address)\n    {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig)\n        public\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        require(sig.length == 65, "invalid signature length");\n\n        assembly {\n            /*\n            First 32 bytes stores the length of the signature\n\n            add(sig, 32) = pointer of sig + 32\n            effectively, skips first 32 bytes of signature\n\n            mload(p) loads next 32 bytes starting at the memory address p into memory\n            */\n\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n}\n')))}d.isMDXComponent=!0}}]);